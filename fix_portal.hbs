  <script>
    const FOCUS_TRAP_DEBUG = false; // set false when done debugging
    window.addEventListener('load', ()=>{
      let ghostPortal = document.getElementById('ghost-portal-root');
      let ghostPortalWrapper = null;
      let portalRewriter = null;

      const identifyTitle = ( iframeDoc) => {
        let title = "Account Management Portal";
        // if there's a signup class on a child, set the title to account signup
        const signupChild = iframeDoc.querySelector('.signup');
        console.log('signupChild', signupChild);
        if(signupChild){
          title = "Account Signup";
        }
        const signinChild = iframeDoc.querySelector('.signin');
        console.log('signinChild', signinChild);
        if(signinChild){
          title = "Account Signin";
        }
        return title;
      }

      const adjustCadenceLabels = (iframeDoc) => {
        // update section.ghost-portal-products - add an aria-label
        const productsSection = iframeDoc.querySelector('section.gh-portal-products');
                  console.log('productsSection', productsSection);
        if(!productsSection) {
          return;
        }

        productsSection.setAttribute('aria-label', 'Subscription options');
        // loop through .gh-portal-product-card . Get the h4.gh-portal-product-name for each 
        // add the name to the aria-label of each gh-portal-btn
        const productCards = productsSection.querySelectorAll('.gh-portal-product-card');
        productCards.forEach(productCard => {
          const productName = productCard.querySelector('h4.gh-portal-product-name').textContent;
          const productButton = productCard.querySelector('.gh-portal-btn');
          productButton.setAttribute('aria-label', `Choose ${productName} subscription`);
          productCard.querySelectorAll('.gh-portal-benefit-checkmark').forEach(benefit => {
            benefit.setAttribute('aria-hidden', 'true');
          });
        });

      }

      const adjustCadenceToggle = (iframeDoc) => {
        const priceToggle = iframeDoc.querySelector('.gh-portal-products-pricetoggle');
        if (!priceToggle) {
          return;
        }

        // Set up as a radiogroup for better screen reader support
        priceToggle.setAttribute('role', 'radiogroup');
        priceToggle.setAttribute('aria-label', 'Billing period');

        const monthlyBtn = priceToggle.querySelector('[data-test-button="switch-monthly"]');
        const yearlyBtn = priceToggle.querySelector('[data-test-button="switch-yearly"]');

        if (monthlyBtn && yearlyBtn) {
          // Set up as radio buttons
          monthlyBtn.setAttribute('role', 'radio');
          yearlyBtn.setAttribute('role', 'radio');

          // Set aria-checked based on active class
          const updateToggleState = () => {
            const monthlyActive = monthlyBtn.classList.contains('active');
            const yearlyActive = yearlyBtn.classList.contains('active');

            monthlyBtn.setAttribute('aria-checked', monthlyActive ? 'true' : 'false');
            yearlyBtn.setAttribute('aria-checked', yearlyActive ? 'true' : 'false');

            // Also add aria-label to include the discount info if present
            const yearlyDiscount = yearlyBtn.querySelector('.gh-portal-maximum-discount');
            if (yearlyDiscount && yearlyActive) {
              const discountText = yearlyDiscount.textContent.trim();
              yearlyBtn.setAttribute('aria-label', `Yearly ${discountText}`);
            } else {
              yearlyBtn.setAttribute('aria-label', 'Yearly');
            }
            monthlyBtn.setAttribute('aria-label', 'Monthly');
          };

          // Initial state
          updateToggleState();

          // Watch for changes (when user clicks to toggle)
          const toggleObserver = new MutationObserver(() => {
            updateToggleState();
          });
          toggleObserver.observe(priceToggle, {
            attributes: true,
            attributeFilter: ['class'],
            subtree: true
          });
        }
      }

      const redrawErrorMessages = (iframeDoc) => {
        // Handle general error message - make it announce assertively
        const generalErrorMessages = iframeDoc.querySelectorAll('.gh-portal-error-message');
        generalErrorMessages.forEach(errorMsg => {
          errorMsg.setAttribute('aria-live', 'assertive');
          errorMsg.setAttribute('role', 'alert');
        });

        // find input.gh-portal-input.error and add aria-invalid="true"
        const errorInputs = iframeDoc.querySelectorAll('input.gh-portal-input.error');
        console.log('errorInputs', errorInputs);
        errorInputs.forEach(errorInput => {
          errorInput.setAttribute('aria-invalid', 'true');
          
          // Find the error message <p> in the same section's labelcontainer
          const inputSection = errorInput.closest('.gh-portal-input-section');
          if (inputSection) {
            const labelContainer = inputSection.querySelector('.gh-portal-input-labelcontainer');
            if (labelContainer) {
              const errorMessage = labelContainer.querySelector('p');
              if (errorMessage) {
                // Give the error message an ID if it doesn't have one
                const errorId = errorMessage.id || `error-${errorInput.id || errorInput.name || 'input'}`;
                if (!errorMessage.id) {
                  errorMessage.id = errorId;
                }
                
                // Link the input to the error message (no aria-live - just read when focused)
                const describedBy = errorInput.getAttribute('aria-describedby');
                if (describedBy && !describedBy.includes(errorId)) {
                  errorInput.setAttribute('aria-describedby', `${describedBy} ${errorId}`);
                } else if (!describedBy) {
                  errorInput.setAttribute('aria-describedby', errorId);
                }
              }
            }
          }
          console.log('errorInput', errorInput);
        });
      }

      const adjustMagiclinkState = (iframeDoc) => {
        try {
          // Check if we're in the magiclink state
          const magiclinkWrapper = iframeDoc.querySelector('.gh-portal-popup-wrapper.magiclink');
          if (!magiclinkWrapper) {
            return;
          }

          // Make the close button container focusable (not the SVG inside)
          const closeContainer = iframeDoc.querySelector('.gh-portal-closeicon-container[data-test-button="close-popup"]');
          if (closeContainer && !closeContainer.hasAttribute('data-magiclink-processed')) {
            // Mark as processed to avoid reprocessing
            closeContainer.setAttribute('data-magiclink-processed', 'true');
            
            // Make container focusable
            if (!closeContainer.hasAttribute('tabindex')) {
              closeContainer.setAttribute('tabindex', '0');
              closeContainer.setAttribute('role', 'button');
              closeContainer.setAttribute('aria-label', 'Close popup');
              
              // Add keyboard event handler for Enter and Space
              const handleKeydown = (e) => {
                if(e.key === 'Enter' || e.key === ' '){
                  e.preventDefault();
                  closeContainer.click();
                }
              };
              closeContainer.addEventListener('keydown', handleKeydown);
            }
            
            // Remove tabindex from SVG if it exists (to avoid duplicate focus)
            const closeIconSvg = closeContainer.querySelector('.gh-portal-closeicon');
            if (closeIconSvg && closeIconSvg.hasAttribute('tabindex')) {
              closeIconSvg.removeAttribute('tabindex');
            }
          }

          // Add aria-live announcement for "Now check your email!"
          const inboxNotification = iframeDoc.querySelector('.gh-portal-inbox-notification');
          if (inboxNotification) {
            // Create or find an aria-live region
            let liveRegion = iframeDoc.getElementById('magiclink-announcement');
            if (!liveRegion) {
              liveRegion = iframeDoc.createElement('div');
              liveRegion.id = 'magiclink-announcement';
              liveRegion.setAttribute('aria-live', 'polite');
              liveRegion.setAttribute('aria-atomic', 'true');
              liveRegion.className = 'sr-only';
              liveRegion.style.cssText = 'position: absolute; width: 1px; height: 1px; padding: 0; margin: -1px; overflow: hidden; clip: rect(0, 0, 0, 0); white-space: nowrap; border-width: 0;';
              iframeDoc.body.appendChild(liveRegion);
            }
            
            // Announce the message (only update if it changed to avoid unnecessary announcements)
            const titleElement = inboxNotification.querySelector('.gh-portal-main-title');
            if (titleElement) {
              const newText = titleElement.textContent.trim();
              if (liveRegion.textContent !== newText) {
                liveRegion.textContent = newText;
              }
            }
          }

          // Ensure code input has a proper label
          const codeInput = iframeDoc.querySelector('#input-otc');
          if (codeInput && !codeInput.hasAttribute('data-magiclink-processed')) {
            // Mark as processed
            codeInput.setAttribute('data-magiclink-processed', 'true');
            
            // Check if it already has a visible label
            const otpSection = codeInput.closest('.gh-portal-otp');
            if (otpSection) {
              // Create a label element if it doesn't exist
              let label = iframeDoc.querySelector('label[for="input-otc"]');
              if (!label) {
                label = iframeDoc.createElement('label');
                label.setAttribute('for', 'input-otc');
                label.className = 'sr-only';
                label.style.cssText = 'position: absolute; width: 1px; height: 1px; padding: 0; margin: -1px; overflow: hidden; clip: rect(0, 0, 0, 0); white-space: nowrap; border-width: 0;';
                label.textContent = 'Enter your verification code';
                codeInput.parentNode.insertBefore(label, codeInput);
              }
              
              // Ensure aria-label is set properly
              if (!codeInput.getAttribute('aria-label') || codeInput.getAttribute('aria-label') === 'Code') {
                codeInput.setAttribute('aria-label', 'Enter your verification code');
              }
            }
          }
        } catch (error) {
          console.error('Error in adjustMagiclinkState:', error);
        }
      }

      // Persistent observer for magiclink state - runs independently
      const magiclinkObservers = new WeakMap();
      const magiclinkTimeouts = new WeakMap();
      const setupMagiclinkObserver = (iframeDoc) => {
        // Only set up once per iframe document
        if (!iframeDoc || !iframeDoc.body) {
          return;
        }
        
        if (magiclinkObservers.has(iframeDoc)) {
          // Observer already exists, just check current state
          adjustMagiclinkState(iframeDoc);
          return;
        }
        
        // Debounced version of adjustMagiclinkState to prevent excessive calls
        const debouncedAdjust = () => {
          const existingTimeout = magiclinkTimeouts.get(iframeDoc);
          if (existingTimeout) {
            clearTimeout(existingTimeout);
          }
          
          const timeout = setTimeout(() => {
            adjustMagiclinkState(iframeDoc);
            magiclinkTimeouts.delete(iframeDoc);
          }, 100); // Small delay to batch rapid mutations
          
          magiclinkTimeouts.set(iframeDoc, timeout);
        };
        
        // Watch for magiclink state appearing dynamically
        const observer = new MutationObserver((mutations) => {
          // Only process if mutations are relevant (not from our own changes)
          const hasRelevantChanges = mutations.some(mutation => {
            // Skip if mutation is from our processed elements
            if (mutation.target.hasAttribute && mutation.target.hasAttribute('data-magiclink-processed')) {
              return false;
            }
            // Skip if mutation is from our live region
            if (mutation.target.id === 'magiclink-announcement') {
              return false;
            }
            return true;
          });
          
          if (hasRelevantChanges) {
            debouncedAdjust();
          }
        });
        observer.observe(iframeDoc.body, {
          childList: true,
          subtree: true,
          attributes: true,
          attributeFilter: ['class']
        });
        
        magiclinkObservers.set(iframeDoc, observer);
        
        // Also check immediately
        adjustMagiclinkState(iframeDoc);
      };

      const rewritePortal = () => {
              const iframeDoc = ghostPortalWrapper.firstChild.contentDocument;
              if(iframeDoc && iframeDoc.head){
                const closeIcon = iframeDoc.querySelector('.gh-portal-closeicon');
                
                // Set up magiclink observer regardless of stylesheet state
                setupMagiclinkObserver(iframeDoc);
                
                // Check if stylesheet already exists and element is ready
                if(!iframeDoc.getElementById('injected-stylesheet') && closeIcon){
                  // Inject stylesheet
                  const styleSheet = iframeDoc.createElement('style');
                  styleSheet.id = 'injected-stylesheet';
                  styleSheet.textContent = `
                    .gh-portal-closeicon {
                      color: var(--grey1);
                    }
                    .gh-portal-closeicon:hover {
                      color: var(--black);
                    }
                    .gh-portal-closeicon-container {
                      cursor: pointer;
                    }
                    .gh-portal-closeicon-container:focus {
                      outline: 2px solid var(--grey1);
                      outline-offset: 2px;
                    }
                    .gh-portal-closeicon-container:focus-visible {
                      outline: 2px solid var(--black);
                      outline-offset: 2px;
                      border-radius: 50%;
                    }
                    .gh-portal-closeicon:focus {
                      outline: 2px solid var(--grey1);
                      outline-offset: 2px;
                    }
                    .gh-portal-closeicon:focus-visible {
                      outline: 2px solid var(--black);
                      outline-offset: 2px;
                      border-radius: 50%
                    }
                    .gh-portal-btn.gh-portal-btn-list:focus-visible, .gh-portal-btn:focus-visible {
                      outline: 2px solid var(--black);
                      outline-offset: 2px;
                    }
                    .gh-portal-input:focus-visible {
                      border-color: var(--black);
                      }
                    .gh-portal-products-pricetoggle {
                     background-color: var(--grey1);
                     }
                    .gh-portal-products-pricetoggle .gh-portal-btn[aria-checked="false"] {
                      color: white;
                      }
                  `;
                  iframeDoc.head.appendChild(styleSheet);

                  // Make close icon keyboard focusable
                  if(!closeIcon.hasAttribute('tabindex')){
                    closeIcon.setAttribute('tabindex', '0');
                    closeIcon.setAttribute('role', 'button');
                    closeIcon.setAttribute('aria-label', 'Close popup');
                    
                    // Add keyboard event handler for Enter and Space
                    closeIcon.addEventListener('keydown', (e) => {
                      if(e.key === 'Enter' || e.key === ' '){
                        e.preventDefault();
                        // Dispatch a click event since SVG elements may not support .click()
                        const clickEvent = new MouseEvent('click', {
                          bubbles: true,
                          cancelable: true,
                          view: iframeDoc.defaultView
                        });
                        closeIcon.dispatchEvent(clickEvent);
                      }
                    });
                  }

                  // Trap tab navigation within the iframe
                  const getFocusableElements = (doc) => {
                    const selector = 'a[href], button, input, select, textarea, [tabindex]:not([tabindex="-1"])';
                    const raw = Array.from(doc.querySelectorAll(selector)).filter((el) => {
                      if (el.hasAttribute('disabled') || el.getAttribute('aria-hidden') === 'true') return false;
                      if (el.getAttribute('tabindex') === '-1') return false;
                      if (el.closest && el.closest('.hidden')) return false;
                      const style = doc.defaultView.getComputedStyle(el);
                      if (style.visibility === 'hidden' || style.display === 'none') return false;
                      const rect = el.getBoundingClientRect();
                      if (rect.width === 0 && rect.height === 0) return false;
                      return true;
                    });
                    const getTabIndex = (el) => {
                      const t = el.getAttribute('tabindex');
                      return t === null ? 0 : parseInt(t, 10);
                    };
                    raw.sort((a, b) => {
                      const ta = getTabIndex(a);
                      const tb = getTabIndex(b);
                      if (ta !== tb) return (ta || Infinity) - (tb || Infinity);
                      return 0;
                    });
                    return raw;
                  };
                  const iframeEl = ghostPortalWrapper.firstChild;

                  // set the title of the iframe 
                  iframeEl.title = identifyTitle(iframeDoc);
                  adjustCadenceLabels(iframeDoc);
                  adjustCadenceToggle(iframeDoc);
                  redrawErrorMessages(iframeDoc);

                  // Watch for error messages appearing dynamically
                  const errorObserver = new MutationObserver((mutations) => {
                    let hasErrors = false;
                    mutations.forEach((mutation) => {
                      if (mutation.type === 'attributes' && mutation.attributeName === 'class') {
                        const target = mutation.target;
                        if (target.classList && target.classList.contains('error') && target.classList.contains('gh-portal-input')) {
                          hasErrors = true;
                        }
                      }
                      if (mutation.type === 'childList') {
                        mutation.addedNodes.forEach((node) => {
                          if (node.nodeType === 1) {
                            if (node.classList && node.classList.contains('error') && node.classList.contains('gh-portal-input')) {
                              hasErrors = true;
                            }
                            if (node.querySelector && node.querySelector('input.gh-portal-input.error')) {
                              hasErrors = true;
                            }
                          }
                        });
                      }
                    });
                    if (hasErrors) {
                      redrawErrorMessages(iframeDoc);
                    }
                  });
                  errorObserver.observe(iframeDoc.body, {
                    childList: true,
                    subtree: true,
                    attributes: true,
                    attributeFilter: ['class']
                  });

                  const moveFocus = (direction) => {
                    const focusable = getFocusableElements(iframeDoc);
                    if (focusable.length === 0) return;
                    const active = iframeDoc.activeElement;
                    const idx = focusable.indexOf(active);
                    let nextIdx;
                    if (direction === 'prev') {
                      nextIdx = idx <= 0 ? focusable.length - 1 : idx - 1;
                    } else {
                      nextIdx = idx < 0 || idx >= focusable.length - 1 ? 0 : idx + 1;
                    }
                    if (FOCUS_TRAP_DEBUG) {
                      console.log('[focus-trap] moveFocus', direction, 'activeIdx', idx, 'nextIdx', nextIdx, 'active', active?.id || active?.tagName, 'target', focusable[nextIdx]?.id || focusable[nextIdx]?.tagName);
                    }
                    focusable[nextIdx].focus();
                  };
                  if (FOCUS_TRAP_DEBUG) {
                    const list = getFocusableElements(iframeDoc);
                    console.log('[focus-trap] focusable count', list.length, list.map((el, i) => i + ':' + (el.id || el.tagName) + (el.className ? '.' + String(el.className).split(/\s+/)[0] : '')));
                  }
                  iframeDoc.addEventListener('keydown', (e) => {
                    if (e.key !== 'Tab') return;
                    const focusable = getFocusableElements(iframeDoc);
                    if (focusable.length === 0) return;
                    const active = iframeDoc.activeElement;
                    if (!iframeDoc.contains(active)) return;
                    if (FOCUS_TRAP_DEBUG) console.log('[focus-trap] iframe keydown Tab', e.shiftKey ? 'Shift+Tab' : 'Tab', 'active', active?.id || active?.tagName);
                    e.preventDefault();
                    e.stopPropagation();
                    moveFocus(e.shiftKey ? 'prev' : 'next');
                  });
                  document.addEventListener('keydown', (e) => {
                    if (e.key !== 'Tab') return;
                    if (FOCUS_TRAP_DEBUG && (document.activeElement === iframeEl || document.activeElement?.closest?.('#ghost-portal-root'))) {
                      console.log('[focus-trap] parent keydown Tab', e.shiftKey ? 'Shift+Tab' : 'Tab', 'activeElement', document.activeElement?.tagName, 'isIframe?', document.activeElement === iframeEl);
                    }
                    if (document.activeElement !== iframeEl) return;
                    const focusable = getFocusableElements(iframeDoc);
                    if (focusable.length === 0) return;
                    e.preventDefault();
                    e.stopPropagation();
                    if (e.shiftKey) {
                      focusable[focusable.length - 1].focus();
                    } else {
                      focusable[0].focus();
                    }
                    if (FOCUS_TRAP_DEBUG) console.log('[focus-trap] parent handled: focused', e.shiftKey ? 'last' : 'first');
                  }, true);
                  
                  console.log('Portal rewritten successfully');
                  clearInterval(portalRewriter);
                }
                
                // Always check and adjust magiclink state, even if stylesheet already exists
                // This handles navigation from sign-in to magiclink state
                adjustMagiclinkState(iframeDoc);
              }
            }

      let portalObserver = new MutationObserver((mutations)=> {
            mutations.forEach((mutation) => {
                if(mutation.addedNodes[0]?.nodeName === 'DIV'){
                ghostPortalWrapper = mutation.addedNodes[0];
                portalRewriter = setInterval(rewritePortal, 50);             
                }
            });         
          });

        portalObserver.observe(ghostPortal, {
            attributes: false,
            characterData: true,
            childList: true,
            subtree: true,
            attributeOldValue: false,
            characterDataOldValue: true
          })
      }) 
  </script>