  <script>
    const FOCUS_TRAP_DEBUG = true; // set false when done debugging
    window.addEventListener('load', ()=>{
      let ghostPortal = document.getElementById('ghost-portal-root');
      let ghostPortalWrapper = null;
      let portalRewriter = null;

      const rewritePortal = () => {
              const iframeDoc = ghostPortalWrapper.firstChild.contentDocument;
              if(iframeDoc && iframeDoc.head){
                const closeIcon = iframeDoc.querySelector('.gh-portal-closeicon');
                
                // Check if stylesheet already exists and element is ready
                if(!iframeDoc.getElementById('injected-stylesheet') && closeIcon){
                  // Inject stylesheet
                  const styleSheet = iframeDoc.createElement('style');
                  styleSheet.id = 'injected-stylesheet';
                  styleSheet.textContent = `
                    .gh-portal-closeicon {
                      color: var(--grey1);
                    }
                    .gh-portal-closeicon:hover {
                      color: var(--black);
                    }
                    .gh-portal-closeicon-container {
                      cursor: pointer;
                    }
                    .gh-portal-closeicon:focus {
                      outline: 2px solid var(--grey1);
                      outline-offset: 2px;
                    }
                    .gh-portal-closeicon:focus-visible {
                      outline: 2px solid var(--black);
                      outline-offset: 2px;
                      border-radius: 50%
                    }
                    .gh-portal-btn.gh-portal-btn-list:focus-visible, .gh-portal-btn:focus-visible {
                      outline: 2px solid var(--black);
                      outline-offset: 2px;
                    }
                    .gh-portal-input:focus-visible {
                      border-color: var(--black);}
                  `;
                  iframeDoc.head.appendChild(styleSheet);
                  
                  // Make close icon keyboard focusable
                  if(!closeIcon.hasAttribute('tabindex')){
                    closeIcon.setAttribute('tabindex', '0');
                    closeIcon.setAttribute('role', 'button');
                    closeIcon.setAttribute('aria-label', 'Close popup');
                    
                    // Add keyboard event handler for Enter and Space
                    closeIcon.addEventListener('keydown', (e) => {
                      if(e.key === 'Enter' || e.key === ' '){
                        e.preventDefault();
                        // Dispatch a click event since SVG elements may not support .click()
                        const clickEvent = new MouseEvent('click', {
                          bubbles: true,
                          cancelable: true,
                          view: iframeDoc.defaultView
                        });
                        closeIcon.dispatchEvent(clickEvent);
                      }
                    });
                  }

                  // Trap tab navigation within the iframe
                  const getFocusableElements = (doc) => {
                    const selector = 'a[href], button, input, select, textarea, [tabindex]:not([tabindex="-1"])';
                    const raw = Array.from(doc.querySelectorAll(selector)).filter((el) => {
                      if (el.hasAttribute('disabled') || el.getAttribute('aria-hidden') === 'true') return false;
                      if (el.getAttribute('tabindex') === '-1') return false;
                      if (el.closest && el.closest('.hidden')) return false;
                      const style = doc.defaultView.getComputedStyle(el);
                      if (style.visibility === 'hidden' || style.display === 'none') return false;
                      const rect = el.getBoundingClientRect();
                      if (rect.width === 0 && rect.height === 0) return false;
                      return true;
                    });
                    const getTabIndex = (el) => {
                      const t = el.getAttribute('tabindex');
                      return t === null ? 0 : parseInt(t, 10);
                    };
                    raw.sort((a, b) => {
                      const ta = getTabIndex(a);
                      const tb = getTabIndex(b);
                      if (ta !== tb) return (ta || Infinity) - (tb || Infinity);
                      return 0;
                    });
                    return raw;
                  };
                  const iframeEl = ghostPortalWrapper.firstChild;
                  const moveFocus = (direction) => {
                    const focusable = getFocusableElements(iframeDoc);
                    if (focusable.length === 0) return;
                    const active = iframeDoc.activeElement;
                    const idx = focusable.indexOf(active);
                    let nextIdx;
                    if (direction === 'prev') {
                      nextIdx = idx <= 0 ? focusable.length - 1 : idx - 1;
                    } else {
                      nextIdx = idx < 0 || idx >= focusable.length - 1 ? 0 : idx + 1;
                    }
                    if (FOCUS_TRAP_DEBUG) {
                      console.log('[focus-trap] moveFocus', direction, 'activeIdx', idx, 'nextIdx', nextIdx, 'active', active?.id || active?.tagName, 'target', focusable[nextIdx]?.id || focusable[nextIdx]?.tagName);
                    }
                    focusable[nextIdx].focus();
                  };
                  if (FOCUS_TRAP_DEBUG) {
                    const list = getFocusableElements(iframeDoc);
                    console.log('[focus-trap] focusable count', list.length, list.map((el, i) => i + ':' + (el.id || el.tagName) + (el.className ? '.' + String(el.className).split(/\s+/)[0] : '')));
                  }
                  iframeDoc.addEventListener('keydown', (e) => {
                    if (e.key !== 'Tab') return;
                    const focusable = getFocusableElements(iframeDoc);
                    if (focusable.length === 0) return;
                    const active = iframeDoc.activeElement;
                    if (!iframeDoc.contains(active)) return;
                    if (FOCUS_TRAP_DEBUG) console.log('[focus-trap] iframe keydown Tab', e.shiftKey ? 'Shift+Tab' : 'Tab', 'active', active?.id || active?.tagName);
                    e.preventDefault();
                    e.stopPropagation();
                    moveFocus(e.shiftKey ? 'prev' : 'next');
                  });
                  document.addEventListener('keydown', (e) => {
                    if (e.key !== 'Tab') return;
                    if (FOCUS_TRAP_DEBUG && (document.activeElement === iframeEl || document.activeElement?.closest?.('#ghost-portal-root'))) {
                      console.log('[focus-trap] parent keydown Tab', e.shiftKey ? 'Shift+Tab' : 'Tab', 'activeElement', document.activeElement?.tagName, 'isIframe?', document.activeElement === iframeEl);
                    }
                    if (document.activeElement !== iframeEl) return;
                    const focusable = getFocusableElements(iframeDoc);
                    if (focusable.length === 0) return;
                    e.preventDefault();
                    e.stopPropagation();
                    if (e.shiftKey) {
                      focusable[focusable.length - 1].focus();
                    } else {
                      focusable[0].focus();
                    }
                    if (FOCUS_TRAP_DEBUG) console.log('[focus-trap] parent handled: focused', e.shiftKey ? 'last' : 'first');
                  }, true);
                  
                  console.log('Portal rewritten successfully');
                  clearInterval(portalRewriter);
                }
              }
            }

      let portalObserver = new MutationObserver((mutations)=> {
            mutations.forEach((mutation) => {
                if(mutation.addedNodes[0]?.nodeName === 'DIV'){
                ghostPortalWrapper = mutation.addedNodes[0];
                portalRewriter = setInterval(rewritePortal, 50);             
                }
            });         
          });

        portalObserver.observe(ghostPortal, {
            attributes: false,
            characterData: true,
            childList: true,
            subtree: true,
            attributeOldValue: false,
            characterDataOldValue: true
          })
      }) 
  </script>